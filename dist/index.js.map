{
  "version": 3,
  "sources": ["../src/constants.ts", "../src/option-utils.ts", "../src/help.ts", "../src/suggest.ts", "../src/parser.ts", "../src/validation.ts", "../src/cli.ts"],
  "sourcesContent": ["export const EXIT_SUCCESS = 0;\nexport const EXIT_FAILURE = 1;\n\nexport const ARGV_OFFSET = 2;\n\nexport const EMPTY = 0;\nexport const SINGLE_CHAR_LENGTH = 1;\n\nexport const COLUMN_GAP = 2;\nexport const INDENT = \"  \";\n\nexport const SHORT_PREFIX = \"-\";\nexport const LONG_PREFIX = \"--\";\nexport const OPTION_TERMINATOR = \"--\";\nexport const EQUALS_SEPARATOR = \"=\";\n\nexport const BOOLEAN_TRUE = \"true\";\nexport const BOOLEAN_FALSE = \"false\";\n\nexport const MAX_SUGGESTION_DISTANCE = 2;\n\nexport const USAGE_COMMAND_PLACEHOLDER = \"<command>\";\nexport const USAGE_OPTIONS_PLACEHOLDER = \"[options]\";\n\nexport const SHORT_NAME_LENGTH = 1;\n", "import { LONG_PREFIX, SHORT_PREFIX } from \"./constants.js\";\nimport type { OptionDefinition, ValueType } from \"./types.js\";\n\n/**\n * Builds the long flag form for an option name.\n */\nexport const buildLongFlag = (name: string): string => `${LONG_PREFIX}${name}`;\n\n/**\n * Builds the short flag form for an option short name.\n */\nexport const buildShortFlag = (short: string): string =>\n  `${SHORT_PREFIX}${short}`;\n\n/**\n * Returns the available flags for an option.\n */\nexport const getOptionFlags = (option: OptionDefinition): string[] =>\n  option.short\n    ? [buildShortFlag(option.short), buildLongFlag(option.name)]\n    : [buildLongFlag(option.name)];\n\nconst getValueHint = (type: ValueType): string =>\n  type === \"boolean\" ? \"\" : ` <${type}>`;\n\n/**\n * Formats the option label for help output.\n */\nexport const formatOptionLabel = (option: OptionDefinition): string => {\n  const flags = getOptionFlags(option).join(\", \");\n  return `${flags}${getValueHint(option.type)}`;\n};\n", "import {\n  COLUMN_GAP,\n  EMPTY,\n  INDENT,\n  USAGE_COMMAND_PLACEHOLDER,\n  USAGE_OPTIONS_PLACEHOLDER,\n} from \"./constants.js\";\nimport { formatOptionLabel } from \"./option-utils.js\";\nimport type {\n  ArgumentDefinition,\n  CommandDefinition,\n  HelpContext,\n  OptionDefinition,\n} from \"./types.js\";\n\nconst hasOwn = <T extends object>(value: T, key: string): boolean =>\n  Object.hasOwn(value, key);\n\nconst formatValue = (value: unknown): string => {\n  if (Array.isArray(value)) {\n    return `[${value.map((item) => formatValue(item)).join(\", \")}]`;\n  }\n\n  if (typeof value === \"string\") {\n    return `\"${value}\"`;\n  }\n\n  return String(value);\n};\n\nconst formatDescription = (\n  definition: OptionDefinition | ArgumentDefinition,\n): string => {\n  const suffixes: string[] = [];\n\n  if (definition.required) {\n    suffixes.push(\"required\");\n  }\n\n  if (hasOwn(definition, \"default\")) {\n    suffixes.push(`default: ${formatValue(definition.default)}`);\n  }\n\n  if (definition.choices && definition.choices.length > EMPTY) {\n    suffixes.push(\n      `choices: ${definition.choices.map((choice) => formatValue(choice)).join(\", \")}`,\n    );\n  }\n\n  if (suffixes.length === EMPTY) {\n    return definition.description;\n  }\n\n  return `${definition.description} (${suffixes.join(\", \")})`;\n};\n\nconst formatArgumentUsage = (definition: ArgumentDefinition): string => {\n  const name = definition.variadic ? `${definition.name}...` : definition.name;\n  return definition.required ? `<${name}>` : `[${name}]`;\n};\n\nconst buildUsage = (\n  context: HelpContext,\n  command?: CommandDefinition,\n): string => {\n  const segments: string[] = [context.name];\n\n  if (command) {\n    segments.push(command.name);\n  } else {\n    segments.push(USAGE_COMMAND_PLACEHOLDER);\n  }\n\n  segments.push(USAGE_OPTIONS_PLACEHOLDER);\n\n  if (command?.args && command.args.length > EMPTY) {\n    segments.push(command.args.map(formatArgumentUsage).join(\" \"));\n  }\n\n  return `Usage: ${segments.join(\" \")}`;\n};\n\nconst renderCommands = (commands: CommandDefinition[]): string[] => {\n  const lines: string[] = [\"\", \"Commands:\"];\n\n  if (commands.length === EMPTY) {\n    lines.push(`${INDENT}(none)`);\n    return lines;\n  }\n\n  const nameWidth = Math.max(\n    ...commands.map((command) => command.name.length),\n    EMPTY,\n  );\n\n  for (const command of commands) {\n    lines.push(\n      `${INDENT}${command.name.padEnd(nameWidth)}${\" \".repeat(COLUMN_GAP)}${command.description}`,\n    );\n  }\n\n  return lines;\n};\n\nconst renderOptions = (\n  title: string,\n  options: OptionDefinition[],\n): string[] => {\n  const lines: string[] = [\"\", title];\n\n  const labelWidth = Math.max(\n    ...options.map((option) => formatOptionLabel(option).length),\n    EMPTY,\n  );\n\n  for (const option of options) {\n    const label = formatOptionLabel(option);\n    lines.push(\n      `${INDENT}${label.padEnd(labelWidth)}${\" \".repeat(COLUMN_GAP)}${formatDescription(option)}`,\n    );\n  }\n\n  return lines;\n};\n\nconst renderArguments = (args: ArgumentDefinition[]): string[] => {\n  const lines: string[] = [\"\", \"Arguments:\"];\n\n  if (args.length === EMPTY) {\n    lines.push(`${INDENT}(none)`);\n    return lines;\n  }\n\n  const nameWidth = Math.max(...args.map((arg) => arg.name.length), EMPTY);\n\n  for (const arg of args) {\n    lines.push(\n      `${INDENT}${arg.name.padEnd(nameWidth)}${\" \".repeat(COLUMN_GAP)}${formatDescription(arg)}`,\n    );\n  }\n\n  return lines;\n};\n\n/**\n * Renders the global help text.\n */\nexport const renderGlobalHelp = (context: HelpContext): string => {\n  const lines: string[] = [buildUsage(context)];\n\n  if (context.description) {\n    lines.push(\"\", context.description);\n  }\n\n  lines.push(...renderCommands(context.commands));\n  lines.push(\n    ...renderOptions(\"Options:\", [\n      context.globalOptions.help,\n      context.globalOptions.version,\n    ]),\n  );\n\n  return lines.join(\"\\n\");\n};\n\n/**\n * Renders the command-specific help text.\n */\nexport const renderCommandHelp = (\n  context: HelpContext,\n  command: CommandDefinition,\n): string => {\n  const lines: string[] = [buildUsage(context, command)];\n\n  if (command.description) {\n    lines.push(\"\", command.description);\n  }\n\n  lines.push(...renderArguments(command.args ?? []));\n  lines.push(\n    ...renderOptions(\"Options:\", [\n      ...(command.options ?? []),\n      context.globalOptions.help,\n      context.globalOptions.version,\n    ]),\n  );\n\n  return lines.join(\"\\n\");\n};\n", "import { MAX_SUGGESTION_DISTANCE } from \"./constants.js\";\n\nconst NORMALIZE_PATTERN = /^-+/;\n\n/**\n * Calculates the Levenshtein distance between two strings.\n */\nexport const levenshteinDistance = (source: string, target: string): number => {\n  if (source === target) {\n    return 0;\n  }\n\n  const sourceLength = source.length;\n  const targetLength = target.length;\n\n  if (sourceLength === 0) {\n    return targetLength;\n  }\n\n  if (targetLength === 0) {\n    return sourceLength;\n  }\n\n  const matrix: number[][] = Array.from({ length: sourceLength + 1 }, () =>\n    Array.from({ length: targetLength + 1 }, () => 0),\n  );\n\n  for (let i = 0; i <= sourceLength; i += 1) {\n    matrix[i][0] = i;\n  }\n\n  for (let j = 0; j <= targetLength; j += 1) {\n    matrix[0][j] = j;\n  }\n\n  for (let i = 1; i <= sourceLength; i += 1) {\n    for (let j = 1; j <= targetLength; j += 1) {\n      const substitutionCost = source[i - 1] === target[j - 1] ? 0 : 1;\n      matrix[i][j] = Math.min(\n        matrix[i - 1][j] + 1,\n        matrix[i][j - 1] + 1,\n        matrix[i - 1][j - 1] + substitutionCost,\n      );\n    }\n  }\n\n  return matrix[sourceLength][targetLength];\n};\n\nconst normalizeCandidate = (value: string): string =>\n  value.replace(NORMALIZE_PATTERN, \"\");\n\n/**\n * Finds the closest candidate within a threshold distance.\n */\nexport const findClosest = (\n  value: string,\n  candidates: string[],\n): string | undefined => {\n  const normalized = normalizeCandidate(value);\n\n  let bestCandidate: string | undefined;\n  let bestDistance = Number.POSITIVE_INFINITY;\n\n  for (const candidate of candidates) {\n    const distance = levenshteinDistance(\n      normalizeCandidate(candidate),\n      normalized,\n    );\n    if (distance < bestDistance) {\n      bestDistance = distance;\n      bestCandidate = candidate;\n    }\n  }\n\n  if (bestDistance <= MAX_SUGGESTION_DISTANCE) {\n    return bestCandidate;\n  }\n\n  return undefined;\n};\n", "import {\n  BOOLEAN_FALSE,\n  BOOLEAN_TRUE,\n  EMPTY,\n  EQUALS_SEPARATOR,\n  LONG_PREFIX,\n  OPTION_TERMINATOR,\n  SHORT_PREFIX,\n  SINGLE_CHAR_LENGTH,\n} from \"./constants.js\";\nimport { buildLongFlag, buildShortFlag } from \"./option-utils.js\";\nimport { findClosest } from \"./suggest.js\";\nimport type {\n  ArgumentDefinition,\n  CommandDefinition,\n  OptionDefinition,\n  ParseError,\n  ParseOutcome,\n} from \"./types.js\";\n\nconst DEFAULT_BOOLEAN_VALUE = false;\n\nconst hasOwn = <T extends object>(value: T, key: string): boolean =>\n  Object.hasOwn(value, key);\n\nconst splitOnEquals = (\n  token: string,\n): { head: string; value: string | undefined } => {\n  const index = token.indexOf(EQUALS_SEPARATOR);\n  if (index === -1) {\n    return { head: token, value: undefined };\n  }\n\n  return {\n    head: token.slice(EMPTY, index),\n    value: token.slice(index + SINGLE_CHAR_LENGTH),\n  };\n};\n\nconst createError = (\n  kind: ParseError[\"kind\"],\n  message: string,\n): ParseError => ({\n  kind,\n  message,\n});\n\nconst getTypeLabel = (type: OptionDefinition[\"type\"]): string => type;\n\nconst formatValue = (value: unknown): string => {\n  if (Array.isArray(value)) {\n    return `[${value.map((item) => formatValue(item)).join(\", \")}]`;\n  }\n\n  if (typeof value === \"string\") {\n    return `\"${value}\"`;\n  }\n\n  return String(value);\n};\n\nconst normalizeChoices = (choices: unknown[] | undefined): string => {\n  if (!choices || choices.length === EMPTY) {\n    return \"\";\n  }\n\n  const formatted = choices.map((choice) => formatValue(choice)).join(\", \");\n  return ` (choices: ${formatted})`;\n};\n\nconst coerceValue = (\n  raw: string,\n  type: OptionDefinition[\"type\"],\n): { ok: true; value: unknown } | { ok: false } => {\n  switch (type) {\n    case \"string\":\n      return { ok: true, value: raw };\n    case \"number\": {\n      const value = Number(raw);\n      if (Number.isNaN(value)) {\n        return { ok: false };\n      }\n      return { ok: true, value };\n    }\n    case \"boolean\":\n      if (raw === BOOLEAN_TRUE) {\n        return { ok: true, value: true };\n      }\n      if (raw === BOOLEAN_FALSE) {\n        return { ok: true, value: false };\n      }\n      return { ok: false };\n  }\n};\n\nconst applyChoices = (\n  value: unknown,\n  definition: OptionDefinition | ArgumentDefinition,\n): boolean => {\n  if (!definition.choices) {\n    return true;\n  }\n\n  return definition.choices.some((choice) => choice === value);\n};\n\nconst isKnownOptionToken = (\n  token: string,\n  longOptions: Map<string, OptionDefinition>,\n  shortOptions: Map<string, OptionDefinition>,\n): boolean => {\n  if (!token.startsWith(SHORT_PREFIX)) {\n    return false;\n  }\n\n  if (token.startsWith(LONG_PREFIX)) {\n    const { head } = splitOnEquals(token);\n    const longName = head.slice(LONG_PREFIX.length);\n    return longOptions.has(longName);\n  }\n\n  const shortName = token.slice(SHORT_PREFIX.length, SHORT_PREFIX.length + 1);\n  return shortOptions.has(shortName);\n};\n\nconst initializeOptionValues = (\n  options: OptionDefinition[],\n): Record<string, unknown> => {\n  const initial: Record<string, unknown> = {};\n  for (const option of options) {\n    if (hasOwn(option, \"default\")) {\n      initial[option.name] = option.default;\n    } else if (option.type === \"boolean\") {\n      initial[option.name] = DEFAULT_BOOLEAN_VALUE;\n    }\n  }\n  return initial;\n};\n\nconst buildOptionMaps = (options: OptionDefinition[]) => {\n  const longOptions = new Map<string, OptionDefinition>();\n  const shortOptions = new Map<string, OptionDefinition>();\n\n  for (const option of options) {\n    longOptions.set(option.name, option);\n    if (option.short) {\n      shortOptions.set(option.short, option);\n    }\n  }\n\n  return { longOptions, shortOptions };\n};\n\nconst parseOptionValue = (\n  option: OptionDefinition,\n  raw: string,\n  label: string,\n): { value?: unknown; error?: ParseError } => {\n  const parsed = coerceValue(raw, option.type);\n  if (!parsed.ok) {\n    return {\n      error: createError(\n        \"InvalidOptionValue\",\n        `Invalid value for option: ${label} (expected ${getTypeLabel(option.type)})`,\n      ),\n    };\n  }\n\n  if (!applyChoices(parsed.value, option)) {\n    return {\n      error: createError(\n        \"InvalidOptionValue\",\n        `Invalid value for option: ${label}${normalizeChoices(option.choices)}`,\n      ),\n    };\n  }\n\n  return { value: parsed.value };\n};\n\nconst parseArgumentValue = (\n  argument: ArgumentDefinition,\n  raw: string,\n): { value?: unknown; error?: ParseError } => {\n  const parsed = coerceValue(raw, argument.type);\n  if (!parsed.ok) {\n    return {\n      error: createError(\n        \"InvalidArgumentValue\",\n        `Invalid value for argument: ${argument.name} (expected ${getTypeLabel(argument.type)})`,\n      ),\n    };\n  }\n\n  if (!applyChoices(parsed.value, argument)) {\n    return {\n      error: createError(\n        \"InvalidArgumentValue\",\n        `Invalid value for argument: ${argument.name}${normalizeChoices(argument.choices)}`,\n      ),\n    };\n  }\n\n  return { value: parsed.value };\n};\n\nconst parseArguments = (\n  positionals: string[],\n  argumentsDefinition: ArgumentDefinition[],\n): { args: Record<string, unknown>; errors: ParseError[] } => {\n  const args: Record<string, unknown> = {};\n  const errors: ParseError[] = [];\n\n  const variadicIndex = argumentsDefinition.findIndex(\n    (definition) => definition.variadic === true,\n  );\n\n  if (variadicIndex === -1 && positionals.length > argumentsDefinition.length) {\n    const extras = positionals.slice(argumentsDefinition.length).join(\", \");\n    errors.push(\n      createError(\"TooManyArguments\", `Too many arguments: ${extras}`),\n    );\n  }\n\n  for (let index = 0; index < argumentsDefinition.length; index += 1) {\n    const definition = argumentsDefinition[index];\n    if (!definition) {\n      continue;\n    }\n\n    if (definition.variadic) {\n      const rest = positionals.slice(index);\n      const values: unknown[] = [];\n\n      if (rest.length === EMPTY && definition.required) {\n        errors.push(\n          createError(\n            \"MissingRequiredArgument\",\n            `Missing required argument: ${definition.name}`,\n          ),\n        );\n      }\n\n      for (const raw of rest) {\n        const { value, error } = parseArgumentValue(definition, raw);\n        if (error) {\n          errors.push(error);\n        } else {\n          values.push(value);\n        }\n      }\n\n      args[definition.name] = values;\n      break;\n    }\n\n    const raw = positionals[index];\n    if (raw === undefined) {\n      if (definition.required) {\n        errors.push(\n          createError(\n            \"MissingRequiredArgument\",\n            `Missing required argument: ${definition.name}`,\n          ),\n        );\n      } else if (hasOwn(definition, \"default\")) {\n        args[definition.name] = definition.default;\n      } else {\n        args[definition.name] = undefined;\n      }\n      continue;\n    }\n\n    const { value, error } = parseArgumentValue(definition, raw);\n    if (error) {\n      errors.push(error);\n    } else {\n      args[definition.name] = value;\n    }\n  }\n\n  return { args, errors };\n};\n\nconst registerOptionValue = (\n  option: OptionDefinition,\n  raw: string,\n  label: string,\n  values: Record<string, unknown>,\n  errors: ParseError[],\n  presentOptions: Set<string>,\n): void => {\n  const parsed = parseOptionValue(option, raw, label);\n  if (parsed.error) {\n    errors.push(parsed.error);\n    return;\n  }\n\n  values[option.name] = parsed.value;\n  presentOptions.add(option.name);\n};\n\nconst buildUnknownOptionMessage = (\n  token: string,\n  candidates: string[],\n): string => {\n  const suggestion = findClosest(token, candidates);\n  if (suggestion) {\n    return `Unknown option: ${token}. Did you mean ${suggestion}?`;\n  }\n  return `Unknown option: ${token}.`;\n};\n\n/**\n * Parses the command arguments and options.\n */\nexport const parseCommandInput = (\n  argv: string[],\n  command: CommandDefinition,\n): ParseOutcome => {\n  const optionDefinitions = command.options ?? [];\n  const argumentDefinitions = command.args ?? [];\n  const { longOptions, shortOptions } = buildOptionMaps(optionDefinitions);\n\n  const values = initializeOptionValues(optionDefinitions);\n  const presentOptions = new Set<string>();\n  const positionals: string[] = [];\n  const errors: ParseError[] = [];\n\n  let index = 0;\n  let allowOptions = true;\n\n  while (index < argv.length) {\n    const token = argv[index];\n    if (token === undefined) {\n      index += 1;\n      continue;\n    }\n\n    if (allowOptions && token === OPTION_TERMINATOR) {\n      allowOptions = false;\n      index += 1;\n      continue;\n    }\n\n    if (\n      allowOptions &&\n      token.startsWith(LONG_PREFIX) &&\n      token.length > LONG_PREFIX.length\n    ) {\n      const { head, value } = splitOnEquals(token);\n      const longName = head.slice(LONG_PREFIX.length);\n      const option = longOptions.get(longName);\n\n      if (!option) {\n        const candidates = optionDefinitions.map((definition) =>\n          buildLongFlag(definition.name),\n        );\n        errors.push(\n          createError(\n            \"UnknownOption\",\n            buildUnknownOptionMessage(token, candidates),\n          ),\n        );\n        index += 1;\n        continue;\n      }\n\n      const label = buildLongFlag(option.name);\n      if (option.type === \"boolean\") {\n        if (value === undefined) {\n          values[option.name] = true;\n          presentOptions.add(option.name);\n        } else {\n          registerOptionValue(\n            option,\n            value,\n            label,\n            values,\n            errors,\n            presentOptions,\n          );\n        }\n        index += 1;\n        continue;\n      }\n\n      if (value === undefined) {\n        const next = argv[index + 1];\n        if (\n          next === undefined ||\n          next === OPTION_TERMINATOR ||\n          isKnownOptionToken(next, longOptions, shortOptions)\n        ) {\n          errors.push(\n            createError(\n              \"MissingOptionValue\",\n              `Missing value for option: ${label}`,\n            ),\n          );\n          index += 1;\n          continue;\n        }\n        registerOptionValue(\n          option,\n          next,\n          label,\n          values,\n          errors,\n          presentOptions,\n        );\n        index += 2;\n        continue;\n      }\n\n      registerOptionValue(option, value, label, values, errors, presentOptions);\n      index += 1;\n      continue;\n    }\n\n    if (\n      allowOptions &&\n      token.startsWith(SHORT_PREFIX) &&\n      token.length > SHORT_PREFIX.length\n    ) {\n      const { head, value } = splitOnEquals(token);\n      const shortBody = head.slice(SHORT_PREFIX.length);\n\n      if (shortBody.length > SINGLE_CHAR_LENGTH) {\n        if (value !== undefined) {\n          errors.push(\n            createError(\n              \"InvalidOptionBundle\",\n              `Invalid option bundle: ${token}`,\n            ),\n          );\n          index += 1;\n          continue;\n        }\n\n        let bundleError = false;\n        for (const shortName of shortBody) {\n          const option = shortOptions.get(shortName);\n          if (!option) {\n            const candidates = optionDefinitions.flatMap((definition) =>\n              definition.short\n                ? [\n                    buildShortFlag(definition.short),\n                    buildLongFlag(definition.name),\n                  ]\n                : [buildLongFlag(definition.name)],\n            );\n            errors.push(\n              createError(\n                \"UnknownOption\",\n                buildUnknownOptionMessage(\n                  buildShortFlag(shortName),\n                  candidates,\n                ),\n              ),\n            );\n            bundleError = true;\n            break;\n          }\n\n          if (option.type !== \"boolean\") {\n            errors.push(\n              createError(\n                \"InvalidOptionBundle\",\n                `Invalid option bundle: ${token}`,\n              ),\n            );\n            bundleError = true;\n            break;\n          }\n\n          values[option.name] = true;\n          presentOptions.add(option.name);\n        }\n\n        if (bundleError) {\n          index += 1;\n          continue;\n        }\n\n        index += 1;\n        continue;\n      }\n\n      const option = shortOptions.get(shortBody);\n      if (!option) {\n        const candidates = optionDefinitions.flatMap((definition) =>\n          definition.short\n            ? [buildShortFlag(definition.short), buildLongFlag(definition.name)]\n            : [buildLongFlag(definition.name)],\n        );\n        errors.push(\n          createError(\n            \"UnknownOption\",\n            buildUnknownOptionMessage(buildShortFlag(shortBody), candidates),\n          ),\n        );\n        index += 1;\n        continue;\n      }\n\n      const label = buildShortFlag(option.short ?? shortBody);\n\n      if (option.type === \"boolean\") {\n        values[option.name] = true;\n        presentOptions.add(option.name);\n        index += 1;\n        continue;\n      }\n\n      if (value === undefined) {\n        const next = argv[index + 1];\n        if (\n          next === undefined ||\n          next === OPTION_TERMINATOR ||\n          isKnownOptionToken(next, longOptions, shortOptions)\n        ) {\n          errors.push(\n            createError(\n              \"MissingOptionValue\",\n              `Missing value for option: ${label}`,\n            ),\n          );\n          index += 1;\n          continue;\n        }\n        registerOptionValue(\n          option,\n          next,\n          label,\n          values,\n          errors,\n          presentOptions,\n        );\n        index += 2;\n        continue;\n      }\n\n      registerOptionValue(option, value, label, values, errors, presentOptions);\n      index += 1;\n      continue;\n    }\n\n    positionals.push(token);\n    index += 1;\n  }\n\n  for (const option of optionDefinitions) {\n    if (option.required && !presentOptions.has(option.name)) {\n      errors.push(\n        createError(\n          \"MissingRequiredOption\",\n          `Missing required option: ${buildLongFlag(option.name)}`,\n        ),\n      );\n    }\n  }\n\n  const { args, errors: argumentErrors } = parseArguments(\n    positionals,\n    argumentDefinitions,\n  );\n\n  errors.push(...argumentErrors);\n\n  if (errors.length > EMPTY) {\n    return { ok: false, errors };\n  }\n\n  return { ok: true, args, options: values };\n};\n", "import { SHORT_NAME_LENGTH, SHORT_PREFIX } from \"./constants.js\";\nimport type {\n  CommandDefinition,\n  GlobalOptions,\n  OptionDefinition,\n} from \"./types.js\";\n\nconst NAME_PATTERN = /^\\S+$/;\n\nconst assertUnique = (values: string[], label: string): void => {\n  const seen = new Set<string>();\n  for (const value of values) {\n    if (seen.has(value)) {\n      throw new Error(`Duplicate ${label}: ${value}`);\n    }\n    seen.add(value);\n  }\n};\n\nconst assertOption = (option: OptionDefinition): void => {\n  if (!NAME_PATTERN.test(option.name)) {\n    throw new Error(`Invalid option name: ${option.name}`);\n  }\n\n  if (option.name.startsWith(SHORT_PREFIX)) {\n    throw new Error(`Invalid option name: ${option.name}`);\n  }\n\n  if (option.short !== undefined && option.short.length !== SHORT_NAME_LENGTH) {\n    throw new Error(`Invalid option short name: ${option.short}`);\n  }\n\n  if (option.short === SHORT_PREFIX) {\n    throw new Error(`Invalid option short name: ${option.short}`);\n  }\n};\n\n/**\n * Ensures a command definition is valid before registration.\n */\nexport const assertValidCommandDefinition = (\n  command: CommandDefinition,\n): void => {\n  if (!NAME_PATTERN.test(command.name)) {\n    throw new Error(`Invalid command name: ${command.name}`);\n  }\n\n  if (command.name.startsWith(SHORT_PREFIX)) {\n    throw new Error(`Invalid command name: ${command.name}`);\n  }\n\n  const options = command.options ?? [];\n  options.forEach(assertOption);\n\n  assertUnique(\n    options.map((option) => option.name),\n    \"option name\",\n  );\n\n  assertUnique(\n    options\n      .map((option) => option.short)\n      .filter((value): value is string => value !== undefined),\n    \"option short name\",\n  );\n\n  const args = command.args ?? [];\n  const variadicIndex = args.findIndex((arg) => arg.variadic === true);\n\n  if (variadicIndex !== -1 && variadicIndex !== args.length - 1) {\n    throw new Error(\"Variadic arguments must be the last argument.\");\n  }\n\n  let hasOptional = false;\n  for (const arg of args) {\n    if (!NAME_PATTERN.test(arg.name)) {\n      throw new Error(`Invalid argument name: ${arg.name}`);\n    }\n\n    if (!arg.required) {\n      hasOptional = true;\n    } else if (hasOptional) {\n      throw new Error(\"Required arguments cannot follow optional arguments.\");\n    }\n  }\n};\n\n/**\n * Ensures global options remain safe and predictable.\n */\nexport const assertValidGlobalOptions = (options: GlobalOptions): void => {\n  if (options.help.type !== \"boolean\") {\n    throw new Error(\"The help option must be boolean.\");\n  }\n\n  if (options.version.type !== \"boolean\") {\n    throw new Error(\"The version option must be boolean.\");\n  }\n\n  assertOption(options.help);\n  assertOption(options.version);\n};\n", "import {\n  ARGV_OFFSET,\n  EMPTY,\n  EXIT_FAILURE,\n  EXIT_SUCCESS,\n  OPTION_TERMINATOR,\n  SHORT_PREFIX,\n} from \"./constants.js\";\nimport { renderCommandHelp, renderGlobalHelp } from \"./help.js\";\nimport { buildLongFlag, getOptionFlags } from \"./option-utils.js\";\nimport { parseCommandInput } from \"./parser.js\";\nimport { findClosest } from \"./suggest.js\";\nimport type {\n  CliIO,\n  CommandContext,\n  CommandDefinition,\n  GlobalOptions,\n  GlobalOptionsOverride,\n  HelpContext,\n} from \"./types.js\";\nimport {\n  assertValidCommandDefinition,\n  assertValidGlobalOptions,\n} from \"./validation.js\";\n\nconst DEFAULT_IO: CliIO = {\n  stdout: (text) => process.stdout.write(`${text}\\n`),\n  stderr: (text) => process.stderr.write(`${text}\\n`),\n};\n\nconst DEFAULT_GLOBAL_OPTIONS: GlobalOptions = {\n  help: {\n    name: \"help\",\n    short: \"h\",\n    description: \"Show help\",\n    type: \"boolean\",\n  },\n  version: {\n    name: \"version\",\n    short: \"v\",\n    description: \"Show version\",\n    type: \"boolean\",\n  },\n};\n\nconst resolveGlobalOptions = (\n  override: GlobalOptionsOverride | undefined,\n): GlobalOptions => {\n  const resolved: GlobalOptions = {\n    help: {\n      ...DEFAULT_GLOBAL_OPTIONS.help,\n      ...override?.help,\n      name: DEFAULT_GLOBAL_OPTIONS.help.name,\n      type: DEFAULT_GLOBAL_OPTIONS.help.type,\n    },\n    version: {\n      ...DEFAULT_GLOBAL_OPTIONS.version,\n      ...override?.version,\n      name: DEFAULT_GLOBAL_OPTIONS.version.name,\n      type: DEFAULT_GLOBAL_OPTIONS.version.type,\n    },\n  };\n\n  assertValidGlobalOptions(resolved);\n  return resolved;\n};\n\nconst formatError = (error: unknown): string => {\n  if (error instanceof Error) {\n    return error.message;\n  }\n\n  return String(error);\n};\n\nconst findCommandIndex = (argv: string[]): number => {\n  for (let index = 0; index < argv.length; index += 1) {\n    const token = argv[index];\n    if (token === undefined) {\n      continue;\n    }\n\n    if (token === OPTION_TERMINATOR) {\n      return index + 1 < argv.length ? index + 1 : -1;\n    }\n\n    if (!token.startsWith(SHORT_PREFIX)) {\n      return index;\n    }\n  }\n\n  return -1;\n};\n\nconst buildCommandSuggestion = (\n  name: string,\n  commands: CommandDefinition[],\n): string | undefined => {\n  const candidate = findClosest(\n    name,\n    commands.map((command) => command.name),\n  );\n  if (!candidate) {\n    return undefined;\n  }\n\n  return `Did you mean ${candidate}?`;\n};\n\nconst buildHelpContext = (\n  cli: CLI,\n  commands: CommandDefinition[],\n): HelpContext => ({\n  name: cli.name,\n  version: cli.version,\n  description: cli.description,\n  commands,\n  globalOptions: cli.options,\n});\n\nclass CLI {\n  readonly name: string;\n  readonly version: string;\n  readonly description: string;\n  readonly options: GlobalOptions;\n  private commands = new Map<string, CommandDefinition>();\n\n  /**\n   * Creates a new CLI instance.\n   */\n  constructor(\n    name: string,\n    version: string,\n    description: string,\n    options?: GlobalOptionsOverride,\n  ) {\n    this.name = name;\n    this.version = version;\n    this.description = description;\n    this.options = resolveGlobalOptions(options);\n  }\n\n  /**\n   * Registers a command definition.\n   */\n  command(definition: CommandDefinition): this {\n    assertValidCommandDefinition(definition);\n\n    if (this.commands.has(definition.name)) {\n      throw new Error(`Command already registered: ${definition.name}`);\n    }\n\n    this.commands.set(definition.name, definition);\n    return this;\n  }\n\n  /**\n   * Runs the CLI and returns an exit code.\n   */\n  async run(\n    argv: string[] = process.argv.slice(ARGV_OFFSET),\n    io: CliIO = DEFAULT_IO,\n  ): Promise<number> {\n    const helpFlags = getOptionFlags(this.options.help);\n    const versionFlags = getOptionFlags(this.options.version);\n\n    const commandIndex = findCommandIndex(argv);\n    const commandName = commandIndex >= EMPTY ? argv[commandIndex] : undefined;\n    const commandArgs =\n      commandIndex >= EMPTY ? argv.slice(commandIndex + 1) : [];\n    const globalArgs =\n      commandIndex >= EMPTY ? argv.slice(EMPTY, commandIndex) : argv;\n\n    const helpRequested = argv.some((arg) => helpFlags.includes(arg));\n    const versionRequested = globalArgs.some((arg) =>\n      versionFlags.includes(arg),\n    );\n\n    const sortedCommands = this.listCommands();\n    const helpContext = buildHelpContext(this, sortedCommands);\n\n    let exitCode: number;\n\n    if (helpRequested) {\n      if (commandName) {\n        const command = this.commands.get(commandName);\n        if (command) {\n          io.stdout(renderCommandHelp(helpContext, command));\n          exitCode = EXIT_SUCCESS;\n          process.exit(exitCode);\n          return exitCode;\n        }\n      }\n\n      io.stdout(renderGlobalHelp(helpContext));\n      exitCode = EXIT_SUCCESS;\n      process.exit(exitCode);\n      return exitCode;\n    }\n\n    if (versionRequested) {\n      io.stdout(`${this.name} ${this.version}`);\n      exitCode = EXIT_SUCCESS;\n      process.exit(exitCode);\n      return exitCode;\n    }\n\n    if (!commandName) {\n      io.stdout(renderGlobalHelp(helpContext));\n      exitCode = EXIT_SUCCESS;\n      process.exit(exitCode);\n      return exitCode;\n    }\n\n    const command = this.commands.get(commandName);\n    if (!command) {\n      const suggestion = buildCommandSuggestion(commandName, sortedCommands);\n      const message = suggestion\n        ? `Unknown command: ${commandName}. ${suggestion}`\n        : `Unknown command: ${commandName}.`;\n      io.stderr(message);\n      exitCode = EXIT_FAILURE;\n      process.exit(exitCode);\n      return exitCode;\n    }\n\n    const parseResult = parseCommandInput(commandArgs, command);\n    if (!parseResult.ok) {\n      const message = parseResult.errors\n        .map((error) => error.message)\n        .join(\"\\n\");\n      io.stderr(message);\n      io.stderr(\n        `Run ${this.name} ${command.name} ${buildLongFlag(this.options.help.name)} for usage.`,\n      );\n      exitCode = EXIT_FAILURE;\n      process.exit(exitCode);\n      return exitCode;\n    }\n\n    const context: CommandContext = {\n      args: parseResult.args,\n      options: parseResult.options,\n      rawArgs: commandArgs,\n    };\n\n    try {\n      await command.action(context);\n      exitCode = EXIT_SUCCESS;\n      process.exit(exitCode);\n      return exitCode;\n    } catch (error) {\n      io.stderr(formatError(error));\n      exitCode = EXIT_FAILURE;\n      process.exit(exitCode);\n      return exitCode;\n    }\n  }\n\n  /**\n   * Returns registered commands in name order.\n   */\n  private listCommands(): CommandDefinition[] {\n    return [...this.commands.values()].sort((left, right) =>\n      left.name.localeCompare(right.name),\n    );\n  }\n}\n\nexport { CLI };\n"],
  "mappings": "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",
  "names": ["hasOwn", "formatValue", "raw", "value", "error", "option", "command"]
}
